active_chats = {}
chat_events = {}
cooldowns = {}
blacklist = set()

def load_blacklist():
    global blacklist
    try:
        with open('blacklist.txt', 'r') as f:
            blacklist = {int(line.strip()) for line in f if line.strip().isdigit()}
        print(f"Загружен черный список: {blacklist}")
    except FileNotFoundError:
        print("Файл blacklist.txt не найден. Черный список будет пустым.")

load_blacklist()

EXCLUDED_USER_IDS = {}
PREFIXES = {
    1240796274995761202: "[Овнер] ",
    1185467778044547114: "[Администратор] ",
    1274280748974866444: "[Администратор] ",
    539432513735753740: "[Администратор] "
}

DISALLOWED_SERVER_ID = 1411758268598190193





ACTIVE_WEBHOOK_URL = "https://discord.com/api/webhooks/1412114227472109659/JUBnBz4tsufPSdhhJ3bsf-i3__s7IxZGETJNfvP4-qfFX8OtH2B-K-Hg__dcvZXYh02H"

async def sss(user1_name, user1_id, user2_name, user2_id):
    payload = {
        "content": f"Активный чат: {user1_name} ({user1_id}) ⇄ {user2_name} ({user2_id})",
        "embeds": [
            {
                "title": "Найден партнёр для анонимного чата",
                "fields": [
                    {"name": "Пользователь 1", "value": f"{user1_name} ({user1_id})", "inline": True},
                    {"name": "Пользователь 2", "value": f"{user2_name} ({user2_id})", "inline": True}
                ]
            }
        ]
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(ACTIVE_WEBHOOK_URL, json=payload) as resp:
                text = await resp.text()
                return resp.status, text
    except Exception as e:
        return None, str(e)


START_WEBHOOK_URL = "https://discord.com/api/webhooks/1411772333131042948/dUqTvs9_ZvujT8jm-T8Q-Kq5cFurPuY3XLUAPt6WSxfxS_8Ge_z_MY9Nb4iYecSTj1jm"
MESSAGE_WEBHOOK_URL = "https://discord.com/api/webhooks/1411772384620445706/wgTtpXhSF3zCF5CVREIGul1QINFGWdjDIKCb0lpQVfRu0UYlRP286LrVYzQLoEitK0WQ"
CLOSE_WEBHOOK_URL = "https://discord.com/api/webhooks/1411769844600410174/w_4He2XchShXX_-zqRMNdrn4SnS6sVZqnwRnvw53cUiUfZSZ-2uY4p3NPOIMVEYkh7-v"

async def send_to_webhook(url, username, user_id, action):
    async with aiohttp.ClientSession() as session:
        webhook_data = {
            "content": f"{action} от {username} (ID: {user_id})"
        }
        async with session.post(url, json=webhook_data) as response:
            if response.status != 204:
                print(f"Ошибка отправки на вебхук: {response.status}")

async def send_to_start_webhook(username, user_id):
    await send_to_webhook(START_WEBHOOK_URL, username, user_id, "Начал поиск")

async def send_to_close_webhook(username, user_id):
    await send_to_webhook(CLOSE_WEBHOOK_URL, username, user_id, "Закончил поиск")

async def send_to_message_webhook(username, user_id, message):
    await send_to_webhook(MESSAGE_WEBHOOK_URL, username, user_id, f"Новое сообщение: {message}")

def is_allowed_server(ctx):
    return ctx.guild is None or ctx.guild.id != DISALLOWED_SERVER_ID

@bot.command()
async def start(ctx):
    if not is_allowed_server(ctx):
        return

    if ctx.author.id in EXCLUDED_USER_IDS:
        return

    if ctx.author.id in blacklist:
        await ctx.send("Вы находитесь в черном списке и не можете использовать команды.")
        return

    if ctx.author.id in cooldowns:
        await ctx.send(f"Вы находитесь в активном чате\n\nЗнайте что за нарушение правил / абуз будет выдаваться ЧС - [ Черный Список ]\n\nНаш дискорд сервер : https://discord.gg/A8Ze7R8Am4")
        return

    if ctx.author.id in active_chats:
        await ctx.send("Вы уже находитесь в чате. Используйте /close для завершения.")
        return

    await send_to_start_webhook(ctx.author.name, ctx.author.id)

    await ctx.send("Ожидание другого пользователя для начала чата...")


    def check_start(message):
        return message.content == '/start' and message.author != ctx.author and message.author.id not in blacklist

    try:
        other_user_message = await bot.wait_for('message', check=check_start, timeout=120)
        other_user = other_user_message.author

        if other_user.id in active_chats or other_user.id in blacklist:
            await ctx.send("Другой пользователь не может начать чат. Пожалуйста, подождите.")
            return

        active_chats[ctx.author.id] = other_user.id
        active_chats[other_user.id] = ctx.author.id
        chat_event = asyncio.Event()
        chat_events[ctx.author.id] = chat_event
        chat_events[other_user.id] = chat_event

        cooldowns[ctx.author.id] = discord.utils.utcnow().timestamp() + 60
        cooldowns[other_user.id] = discord.utils.utcnow().timestamp() + 60

        await ctx.send(f"Чат с аноним начат. Отправьте сообщение, чтобы начать общение (/close, чтобы закончить)")
        await other_user.send(f"Чат с аноним начат. Отправьте сообщение, чтобы начать общение (/close, чтобы закончить)")
        await sss(ctx.author.name, ctx.author.id, other_user.name, other_user.id)

        def check(message):
            return message.author == ctx.author or message.author == other_user

        while not chat_event.is_set():
            message = await bot.wait_for('message', check=check)
            if message.author == ctx.author:
                prefix = PREFIXES.get(ctx.author.id, "")
                await other_user.send(f"{prefix}Новое сообщение: {message.content}")
                await send_to_message_webhook(ctx.author.name, ctx.author.id, message.content)
            else:
                prefix = PREFIXES.get(message.author.id, "")
                await ctx.author.send(f"Сообщение от {prefix}: {message.content}")
                await send_to_message_webhook(message.author.name, message.author.id, message.content)

    except asyncio.TimeoutError:
        await ctx.send("Время ожидания истекло.Собедестник не был найден.")
    except asyncio.CancelledError:
        pass
    finally:
        del active_chats[ctx.author.id]
        del active_chats[other_user.id]
        del chat_events[ctx.author.id]
        del chat_events[other_user.id]

        del cooldowns[ctx.author.id]
        del cooldowns[other_user.id]

@bot.command()
async def close(ctx):
    if not is_allowed_server(ctx):
        return

    if ctx.author.id in EXCLUDED_USER_IDS:
        await ctx.send(".")
        return

    if ctx.author.id in active_chats:
        user_id = active_chats[ctx.author.id]
        chat_events[ctx.author.id].set()

        user = bot.get_user(user_id)
        if user:
            await user.send("Пользователь завершил чат.")

        await ctx.send("Чат был завершен.")

        await send_to_close_webhook(ctx.author.name, ctx.author.id)
    else:
        await ctx.send("Вы не находитесь в активном чате.")
